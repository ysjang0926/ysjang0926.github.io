---
layout: post
title:  "[머신러닝 시스템 설계] 이벤트 추천 시스템 (feat. pointwise LTR, 신경망, mAP)"
subtitle:   "Event Recommendation System"
categories: data
tags: ml
comments: true
use_math: true
---

- 해당 포스팅은 가상 면접 사례로 배우는 [가상 면접 사례로 배우는 머신러닝 시스템 설계 기초](https://www.yes24.com/Product/Goods/124939147) 책의 내용을 읽고 개인적인 학습 목적 하에 작성된 글입니다.
- 7장(이벤트 추천 시스템) 내용 위주이며, 주관적인 의견도 포함되어있으니 참고만 부탁드립니다.😊

----------

# 💎 7장: 이벤트 추천 시스템
7장에서는 이벤트브라이트와 유사한 **이벤트 추천 시스템**을 설계합니다. 이벤트브라이트는 **사용자가 이벤트를 생성, 검색 및 등록할 수 있는 인기 있는 이벤트 관리 및 티켓팅 마켓플레이스**입니다. <br>
추천 시스템은 **경험을 개인화하고 사용자와 관련된 이벤트를 표시**합니다.
![image](https://github.com/ysjang0926/ysjang0926.github.io/assets/54492747/5f0ce489-e53f-4fba-811b-832cca0c2500)

<br>

## 1️⃣<font color = "#0591f5"> 요구사항 명확화</font>
해당 시스템은 **위치 기반 이벤트 추천 시스템 구축**에 초점을 맞추고 있습니다.
* **비즈니스 목표**
	* 티켓 판매 수 증가
* **가정**
	* 사용자는 이벤트만 지원 (호텔, 레스토랑 예약 X)
	* 이벤트는 한번만 발생한 후 만료되는 임시 단발성 항목
* **이벤트 정보**
	* 무료, 유료 둘다 지원 가능
	* 매월 약 100만 건의 이벤트를 진행하고 있음
* **사용자 수**
	* 웹사이트 또는 앱을 방문하는 일간 능동 사용자(daily active user, DAU) 수는 100만명
* **이벤트 속성**
	* 이벤트의 텍스트 설명 / 가격대 / 위치 / 날짜 및 시간
* **데이터**
	* 수작업으로 라벨링 된 데이터세트는 없음
	* 이벤트 및 사용자 상호작용 데이터를 사용하여 학습 데이터세트 구성 가능
	* 위치 기반 추천 시스템에 초점을 맞추고 있으므로, 위치 데이터 사용 가능 (위치 파악 및 데이터 공유 ok) 
	* 즉, 타사 서비스를 사용하여 위치 데이터 얻을 수 있음
		* 두 위치 간의 거리와 이동 시간을 효율적으로 계산하는 것이 중요함
		* 구글 지도 API나 다른 지도 서비스와 같은 외부 API 사용 가능
* **친구 기능**
	* 친구 정보는 개인화된 이벤트 추천 시스템을 구축하는데 유용함
	* 사용자는 플랫폼에서 친구 관계를 맺을 수 있음
	* 친구 관계는 양방향으로 이루어짐
* **초대 기능**
	* 사용자가 다른 사용자를 이벤트에 초대 가능
	* 이벤트에 등록 옵션만 사용할 수 있음 <br>

> ##### 📍 Summary
> * 사용자에게 개인화된 이벤트 목록을 표시하는 이벤트 추천 시스템 설계
> * 이벤트가 종료되면 사용자는 더이상 이벤트에 등록할 수 없음
> * 사용자는 이벤트 등록 외에도 다른 사용자를 이벤트에 초대하고 친구 관계를 형성할 수 있음
> * 훈련 데이터는 사용자 상호작용을 통해 온라인으로 구축되어야 함
> * **주요 목표 : 전체 티켓 판매 수 증가**

<br><br>

## 2️⃣<font color = "#0591f5"> 머신러닝 작업으로 문제를 구조화</font>
### <font color = "#387af5">머신러닝 목표 정의</font>
* **비즈니스 목표** : 티켓 판매를 늘리는 것
* **머신러닝 목표** : 이벤트 등록수를 극대화 하는 것

<br>

### <font color = "#387af5">시스템의 입력 및 출력 지정</font>
* **입력** : 사용자
* **출력** : 사용자와의 관련성에 다라 순위가 매겨진 상위 k개의 이벤트

<br>

### <font color = "#387af5">적합한 머신러닝 유형 선택</font>
추천 문제를 해결하는 방법에는 여러 가지가 있습니다.
* 인기 이벤트 추천과 같은 간단한 규칙
* 콘텐츠 기반 또는 협업 필터링을 사용하는 임베딩 기반 모델
* 랭킹(ranking) 문제로 재구성하기
	* pointwise, pairwise, listwise

해당 챕터에서는 작업을 **순위 문제**로 재구성하고, **LTR(Learning to Rank)을 사용**하여 해결합니다. LTR은 **지도 학습을 적용하여 순위 문제를 해결하는 알고리즘 기법의 하나**입니다.

순위 문제는 공식적으로 다음과 같이 정의할 수 있습니다.
> 쿼리와 항목 목록이 있을 때, 쿼리와 관련성이 가장 높은 항목부터 관련성이 가장 낮은 항목으로 순서를 정하는 최적의 방법은 무엇일까?

일반적으로 pointwise, pairwise, listwise의 세가지 LTR 접근 방식이 있습니다.
#### ⬛ pointwise LRT
각 항목을 검토하고 분류 또는 회귀 방법을 사용하여 **쿼리와 항목 간의 관련성**을 예측합니다. 한 항목의 점수는 다른 항목과 독립적으로 예측된다는 점을 유의합니다.
* input : 항목, 쿼리
* model : pointwise 순위 모델
* output : 연관성 점수
최종 순위는 예측된 연관성 점수를 정렬하여 결정합니다. <br>

#### ⬛ pairwise LRT
모델이 항목 2개를 가져와서 **어떤 항목이 쿼리와 더 관련성이 높은지** 예측합니다.
* input : <항목 x, 항목 y>, 쿼리
* model : pairwise 순위 모델
* output : 항목 y > 항목 x
가장 많이 사용되는 pairwise LTR 알고리즘은 RankNet, LambdaRank, LambdaMART가 있습니다. <br>

#### ⬛ listwise LRT
**쿼리가 주어졌을 때 전체 항목 목록에서 최적의 순서를 예측**합니다.
* input : <항목 1, 항목 2, ..., 항목 N>, 쿼리
* model : listwise 순위 모델
* output : 항목 5>항목 2>...>항목 8
인기 있는 listwise LRT 알고리즘은 SoftRank, ListNet, AdaRank가 있습니다.

일반적으로 pairwise 방식과 listwise 방식이 더 정확한 결과를 만들어 내지만, 구현 및 훈련은 더 어렵습니다. <br>
이 문제는 간단하게 진행하기 위해 pointwise 접근법을 사용합니다.
* 이진 분류 모델 사용
	*  한 번에 하나의 이벤트를 가져와서 사용자가 등록할 확률을 예측
* input : 사용자, 이벤트
* output : 이벤트 등록 확률

<br><br>

## 3️⃣<font color = "#0591f5"> 데이터 준비</font>
### <font color = "#387af5">데이터 엔지니어링</font>
이벤트 관리 플랫폼은 주로 사용자와 이벤트에 중점을 둬서 다음과 같은 데이터를 사용할 수 있다고 가정합니다.
* 사용자
* 이벤트
* 친구 관계
* 상호작용

#### ⬛ 사용자
사용자 데이터 스키마는 다음과 같습니다.
* ID / Username / Age / Gender / City / Country / Language / Time zone <br>

#### ⬛ 이벤트
이벤트 데이터는 다음과 같습니다.
* ID / 호스트 사용자 ID / 범주&하위범주 / 설명 / 가격 / 위치 / 날짜&시간 <br>

#### ⬛ 사용자
각 행은 두 사용자의 친구 관계가 형성된 시점을 타임스탬프로 보여 줍니다.
* 사용자 ID 1 / 사용자 ID 2 / 친구 관계가 형성된 타임스탬프 <br>

#### ⬛ 상호작용
이벤트 등록, 초대 및 노출수와 같은 사용자 상호작용 데이터가 저장되어 있습니다.
* 사용자 ID / 이벤트 ID / 상호작용 유형 / 상호작용 값 / 위치(위도, 경도) / 타임스탬프

<br>

### <font color = "#387af5">피처 엔지니어링</font>
이벤트 기반 추천은 기존 추천보다 더 까다롭습니다. 이벤트는 영화나 책과는 근본적으로 다르며, 이벤트가 끝난 후에는 더이상 등록 요청이 생기지 않습니다.

이벤트는 일반적으로 수명이 짧기 때문에 이벤트가 생성된 후 종료될 때까지의 시간이 짧아서, 특정 이벤트에 대해 사용할 수 있는 과거 상호작용 데이터가 많지 않습니다. <br>
→ 이런 이유로 이벤트 기반 추천은 본질적으로 콜드 스타트이며, 지속적으로 '신제품 문제'를 겪습니다.

이러한 문제를 극복하기 위해 피처 엔지니어링에 노력을 기울여 의미 있는 피처를 가능한 많이 만드는 것이 중요합니다.
* 위치 관련 피처
* 시간 관련 피처
* 소셜 관련 피처
* 사용자 관련 피처
* 이벤트 관련 피처 <br>

#### ⬛ 위치 관련 피처
##### 📍 이벤트 위치의 접근성은 어느 정도인지
**이벤트 장소의 접근성**은 중요한 요소이기 때문에, 접근성을 파악하기 위한 피처를 만들어야 합니다.
> 예시 : 이벤트가 대중교통에서 멀리 덜어진 언덕 높은 곳에 있는 경우는 이동 시간 때문에 사용자가 이벤트에 참석하지 않을 수 있음 <br>

<details>
<summary> 📌 도보 점수 </summary>
<div markdown="1">

* 0~100사이의 숫자로, 주변 편의 시설까지의 거리를 기준으로 해당 위치까지 얼마나 편하게 이동할 수 있는지 측정함
* 편의 시설까지의 거리, 보행자 친화성, 인구 밀도 등 다양한 요소를 분석하여 계산함
* 구글 지도 등의 외부 데이터 소스에서 얻을 수 있다고 가정함
* 도보 점수를 5가지 범주로 버킷화하여 보여줌

</div>
</details>

<details>
<summary> 📌 도보 점수 유사도 </summary>
<div markdown="1">

* 이벤트의 도보 점수와 사용자가 등록한 이전 이벤트의 평균 도보 점수의 차이

</div>
</details>

<details>
<summary> 📌 그 외 점수 </summary>
<div markdown="1">

* 대중교통 점수, 대중교통 점수 유사성, 자전거 점수, 자전거 점수 유사성

</div>
</details>

##### 📍 이벤트가 사용자와 같은 국가 및 도시에서 진행되는지
사용자에게 매우 중요한 결정 요소는 **현재 있는 국가와 도시에서 이벤트가 열리는지 여부**입니다. 여기서는 2가지 피처를 생성할 수 있습니다.
* **사용자의 국가가 이벤트하는 국가과 동일한 경우**
	* 동일할 때 1, 그렇지 않은 경우는 0
* **사용자의 도시가 이벤트하는 도시와 동일한 경우**
	* 동일할 때 1, 그렇지 않은 경우는 0 <br>

##### 📍 사용자가 거리에 불편함을 느끼지는 않는지
일부 사용자는 자신의 위치에서 가까운 이벤트를 선호하는 반면, 다른 사용자는 멀리 떨어진 이벤트를 선호할 수 있습니다.
* **사용자 위치와 이벤트 위치 사이의 거리**
	* 외부 API에서 가져와서 몇가지 범주로 버킷화할 수 있음
	* ex) 0: 1마일 미만 / 1: 1~마일 / ... / 5: 100마일 이상
* **거리유사도**
	* 이벤트까지의 거리와 사용자가 이전에 등록한 이벤트와의 평균거리(실제로는 중앙값 또는 백분위수 범위 사용 가능)의 차이 <br>

#### ⬛ 시간 관련 피처
##### 📍 이벤트까지 남은 시간이 충분한지
사용자마자 이벤트를 계획하는 시간이 다르기 때문에, 이를 포착하기 위한 피처가 필요합니다.

<details>
<summary> 📌 이벤트 시작까지 남은 시간 </summary>
<div markdown="1">

* 여러 범주로 버킷화하여 원-핫 인코딩할 수 있음
* ex) 0: 이벤트 시작까지 1시간 미만 남음 / 1: 1-2시간 / ... / 7: 3-7일 /  8: 7일 이상

</div>
</details>

<details>
<summary> 📌 남은 시간 유사도 </summary>
<div markdown="1">

* 이벤트 개최까지 '남은 시간'과 사용자가 이전에 등록한 이벤트들의 평균 '남은 시간'의 차이

</div>
</details>

<details>
<summary> 📌 사용자 위치에서 이벤트 위치까지의 예상 이동 시간 </summary>
<div markdown="1">

* 외부 서비스에서 가져와서 범주별로 버킷화함

</div>
</details>

<details>
<summary> 📌 예상 이동 시간 유사도 </summary>
<div markdown="1">

* 해당 이벤트까지의 예상 이동 시간과 사용자가 이전에 등록한 이벤트의 평균 예상 이동 시간 간의 차이

</div>
</details>

##### 📍 날짜와 시간이 사용자에게 편리한지
사용자마다 선호하는 이벤트 요일/시간대가 다를 것입니다. (주말/평일, 오전/저녁 등) <br>
요일 및 시간에 대한 사용자의 과거 선호도를 파악하기 위해 사용자 프로필을 만들어서, 요일 및 시간별 유사도를 추가할 수 있습니다. <br>

#### ⬛ 소셜 관련 피처
##### 📍 이 이벤트에는 몇 명이 참석하는지
일반적으로 다른 참석자가 많으면 사용자가 이벤트에 등록할 가능성이 더 높습니다.
* 이 이벤트에 등록한 사용자 수
* 노출수 대비 전체 등록 사용자 수 비율
* 등록된 사용자 유사도 : 해당 이벤트의 등록 사용자 수와 이전에 등록된 이벤트의 차이 <br>

##### 📍 친구의 참석과 관련된 피처
친구가 참석하는 경우 사용자가 이벤트에 등록할 가능성이 더 높습니다.
* 이 이벤트에 등록한 사용자의 친구 수
* 전체 친구 대비 등록한 친구 수 비율
* 등록한 친구 유사도: 해당 이벤트에 등록된 친구 수와 이전에 등록된 이벤트의 친구 수의 차이 <br>

##### 📍 다른 사람이 사용자를 초대했는지
사용자는 초대받은 이벤트에 참석할 가능성이 더 높습니다.
* 이 사용자를 이벤트에 초대한 친구 수
* 이 사용자를 이벤트에 초대한 동료 사용자 수 <br>

##### 📍 이벤트 호스트가 사용자의 친구인지
사용자는 친구가 만든 이벤트에 참석하는 경향이 있습니다.
* binary 피처 생성 : 이벤트 호스트가 사용자의 친구인 경우 1이고, 그렇지 않은 경우는 0  <br>

##### 📍 이 호스트가 이전에 만든 이벤트에 사용자가 얼마나 자주 참석했는지
특정 호스트가 만드는 이벤트에 관심이 있는 사용자도 있습니다. <br>

#### ⬛ 사용자 관련 피처
##### 📍 연령 및 성별
일부 이벤트는 특정 연령과 성별을 대상으로 합니다.
> '기술 분야 여성', '20대에 성공하기 위한 인생 교훈'은 특정 인구 통계학적 그룹에 특화된 이벤트의 예시
* 원-핫 인코딩으로 인코딩된 사용자 성별
* 사용자의 연령, 여러 범주로 버킷화하고 원-핫 인코딩함 <br>

#### ⬛ 이벤트 관련 피처
##### 📍 이벤트 가격
이벤트 가격은 사용자가 이벤트 등록을 결정하는 데 영향을 미칠 수 있습니다. 
* **이벤트 가격을 몇가지 범주로 버킷화**
	* ex) 0: 무료 / 1: $1~$99 / ... / 4: $2,000 이상
* **가격 유사도**
	* 해당 이벤트의 가격과 사용자가 이전에 등록한 이벤트의 평균 가격 차이 <br>

##### 📍 이 이벤트의 설명이 이전에 등록된 설명과 얼마나 유사한지
이것은 이전에 등록된 이벤트를 기반으로 사용자의 관심사를 나타냅니다. <br>
이를 파악하기 위해 이벤트 설명과 사용자가 이전에 등록한 이벤트 설명 간의 유사성을 나타내는 피처를 만듭니다.
* 유사도를 계산하기 위해 TF-ID를 사용하여 설명을 숫자 벡터로 변환
* 코사인 거리르 사용하여 유사도를 계산

<br>

위의 예시 외에도 실제로 생성할 수 있는 예측 피처는 매우 많습니다. 관련하여 추가적으로 더 논의할 부분도 존재합니다.

<details>
<summary> 📣 잠재적인 대화 주제들 </summary>
<div markdown="1">

* **배치 피처와 스트리밍 피처 비교**
	* 배치(정적) 피처 : 연령, 성별, 이벤트 설명과 같이 자주 변경되지 않는 피처
		* 배치 처리를 사용하여 주기적으로 계산하고 피처 저장소에 저장할 수 있음
	* 스트리밍(동적) 피터 : 이벤트에등록한 사용자수, 이벤트까지 남은 시간과 같이 빠르게 변경되는 피처
* **피처 연산 효율성**
	* 실시간으로 피처를 계산하는 방식은 효율적이지 않기 때문에, 이를 방지할 수 있는 방법 논의 必
	* AS-IS : 사용자의 현재 위치와 이벤트 위치 사이의 거리를 피처로 계산
	* TO-BE : 두 위치를 두 개의 개별 피처로 모델에 전달하고 모델이 두 위치에서 유용한 정보를 암시적으로 계산
* **감쇠계수(decay factor) 사용**
	* 사용자의 마지막 상호작용 X에 관련된 피처에 감쇠계수를 사용
	* 감쇠계수는 사용자의 최근 상호작용/행동에 더 많은 가중치를 부여함
* **임베딩 학습을 사용**
	* 임베딩 학습으로 각 이벤트와 사용자를 임베딩 벡터로 변환함
	* 이벤트와 사용자를 나타내는 피처로 사용됨
* **사용자의 속성으로 피처를 만들면 생길 수 있는 편견**
	* 나이나 성별에 의존하여 지원자가 직무에 적합한지 판단하는 건 차별을 유발할 수 있음

</div>
</details>

<br><br>

## 4️⃣<font color = "#0591f5"> 모델 개발</font>

### <font color = "#387af5">모델 선택</font>
이진 분류 문제는 다양한 머신러닝 방법으로 해결할 수 있습니다. <br>
이벤트 추천 시스템에는 다음과 같은 특징이 있기 때문에, 아래의 다양한 머신러닝 방법들이 적합한지 여부를 보고자 합니다.
* 결과와 선형적인 상관관계가 없는 피처들 존재 (복잡한 관계)
* 새로운 데이터에 맞게 모델을 조정하기 위해 지속적인 학습 필요

#### ⬛ 로지스틱 회귀
입력 피처의 수가 매우 많을 경우 목표 변수(binary result)와 복잡하고 비선형적인 관계를 갖는 경우가 많습니다. 그렇기 때문에 로지스틱 회귀는 이러한 복잡성은 학습하기 어려울 수 있습니다.

<details>
<summary> 🔨 장단점 </summary>
<div markdown="1">

* 장점
	* 빠른 추론 속도 : 입력된 피처의 가중치 조합을 계산하는 속도가 빠름
	* 효율적인 학습 : 구조가 단순하기 때문에 구현, 해석, 훈련이 쉽고 빠르게 이루어짐
	* 데이터가 선형적으로 분리 가능한 경우에 잘 작동함
	* 해석 가능하고 이해가 쉬움 : 피처에 할당된 가중치를 통해 피처의 중요도 파악 가능
* 단점
	* 비선형 문제는 로지스틱 회귀로 해결할 수 없음
	* 다중공선성이 있는 경우 작업을 잘 학습할 없음

</div>
</details>

#### ⬛ 의사 결정 트리
DT는 예측을 위해 의사 결정과 그에 따른 가능한 결과를 나타내는 트리 모델을 사용하는 또 다른 학습 방법입니다.
<details>
<summary> 🔨 장단점 & 배깅/부스팅 </summary>
<div markdown="1">

* 장점
	* 빠른 훈련
	* 빠른 추론
	* 데이터 준비가 거의 또는 전혀 필요하지 않음 : 입력 피처의 분포에 의존하지 않기 때문에 정규화 or 스케일링이 필요하지 않음
* 단점
	* 최적이 아닌 의사 결정 경계
	* 과대적합 : 데이터의 작은 변화에 매우 민감

DT의 민감도를 낮추기 위해 배깅과 부스팅이 많이 쓰이고 있습니다.
* 배깅
	* 훈련 데이터의 여러 하위 집합에 대해 머신러닝 모델 세트를 병렬로 훈련하는 앙상블 학습 방법
	* 이렇게 훈련된 모든 모델의 예측을 결합하여 최종 예측을 만들기 때무넹, 모델의 민감도(분산)가 크게 줄어듦
	* ex) Random Forest
	* 모델이 과소적합(높은 편향)에 직면했을 때 도움이 되지 않음
* 부스팅
	* 예측 오류를 줄이기 위해 여러 개의 약한 분류기를 순차적으로 훈려하는 방식을 말함
	* 데이터 변화에 덜 민감한 강력한 모델을 만들 수 있음
	* 분류기는 이전 분류기의 실수를 기반으로 훈련하기 때문에 순차적으로 작동하게 디어, 서빙 시간이 늘어남
	* ex) AdaBoost, XGBoost, GradientBoost

</div>
</details>

#### ⬛ 그레디언트 부스트 결정 트리(GBDT)
DT를 개선하기 위해 GB를 활용하는 트리 기반 모델입니다. GBDT의 가장 큰 단점은 **지속적인 학습에 적합하지 않다**는 점입니다. <br>
이벤트 추천 시스템에서는 최근 사용자 상호작용, 등록, 새로운 이벤트, 심지어 신규 사용자 등 새로운 데이터가 지속적으로 시스템에 입력됩니다. 좋은 이벤트 추천 시스템을 위해서는 **새로운 데이터에 지속적으로 적응하는 것**이 중요합니다. <br>
지속적인 학습이 불가능하다면, GBDT를 처음부터 다시 정기적으로 재학습시키는 데 큰 비용이 필요합니다.

<details>
<summary> 🔨 장단점 </summary>
<div markdown="1">

* 장점
	* 간편한 데이터 준비
	* 편차와 편향성을 줄임
	* 구조화된 데이터와 잘 작동함
* 단점
	* 반복 횟수, 트리 깊이, 정규화 매개변수 등 조정할 하이퍼파라미터가 많음
	* 비정형 데이터에서는 잘 작동하지 않음
	* 지속적인 학습에는 적합하지 않음 (ex. 스트리밍 데이터)

</div>
</details>

#### ⬛ 신경망
신경망은 이벤트 추천 시스템의 문제(비선형 관계, 지속적인 학습 필요)를 해결하는 데 적합합니다.
* 비선형적 의사 결정 경계가 있는 복잡한 작업 학습 가능
* 새로운 데이터를 매우 쉽게 미세 조정할 수 있어 지속적인 학습에 이상적임
* 
<details>
<summary> 🔨 장단점 </summary>
<div markdown="1">

* 장점
	* 지속적인 학습
	* 비정형 데이터와 잘 작동
	* 표현력 : 학습 매개변수의 수가 많기 때무넹 표현력이 뛰어남
		* 매우 복잡한 작업과 비선형적인 의사 결정 경계를 학습할 수 있음
* 단점
	* 훈련하는 데 계산 비용이 많이 들어감
	* 입력 데이터의 품질이 결과에 큰 영향을 미침
		* 정규화, 로그 스케일링, 원-핫 인코딩 등과 같은 데이터 준비 필수
	* 대규모 하긋ㅂ 데이터 필요
	* 블랙박스 특성
		* 입력 피처가 여러 계층의 비선형 변환을 거치기 때문에 각 피처가 결과에 미치는 영향을 파악하기 쉽지 않음

</div>
</details>

#### ⬛ 어떤 모델을 선택해야 하는지
어떤 모델이 가장 적합한지 결정하기 위해서는 대부분 여러 가지 모델을 실험해야하며, 다양한 요소에 따라 적합한 모델을 선택할 있습니다.
* 작업의 복잡성
* 데이터 배포 및 데이터 유형
* 교육 비용, 속도, 모델 크기 등과 같은 제품 요구사항 또는 제약 조건

이 문제에서는 **GBDT와 신경망 모두 실험에 적합한 후보**입니다. <br>
1. 구현과 훈련이 빠른 GBDT 변형인 XGBoost로 시작하여, 이 결과를 초기 기준선으로 사용
2. 기준선이 정해지면 신경망으로 더 나은 모델을 구축할 수 있는 가능성 타진

다음과 같은 이유로 이 방법에서는 **신경망**이 적절한 방식이라고 생각합니다.
* **시스템에서 방대한 훈련 데이터를 사용할 수 있음**
	* 사용자는 시스템과 지속적으로 상호작용함
	* 사용자 수를 고려하면, 이는 훈련에 사용할 수 있는 방대한 양의 데이터가 생성됨
* **비선형 데이터 학습 가능**
	* 데이터는 선형적으로 분리되지 않을 수 있음

신경망 아키텍처를 설계할 때는 **은닉 계층의 수, 각 계층의 뉴런, 활성화 함수 등 여러 가지 하이퍼파라미터를 고려**해야 합니다. 

<br>

### <font color = "#387af5">모델 훈련</font>
#### ⬛ 데이터세트 구성
훈련 및 평가 데이터세트의구축은 모델 개발의 필수 단계입니다. 피처와 그 라벨을 계산하는 방법을 보겠습니다. <br>
단일 데이터 포인트를 구성하기 위해 상호작용 데이터 에서 <사용자, 이벤트> 쌍을 추출하고 이 쌍으로부터 입력 피처를 계산합니다. 그런 다음 사용자가 이벤트에 등록한 경우 데이터 포인트에 1을, 등록하지 않은 경우 0을 라벨로 지정합니다.

데이터를 구성한 후 **클래스 불균형 문제**가 발생할 수 있습니다. 그 이유는 사용자가 하나의 이벤트에 등록하기 전에 수십, 수백 개의 이벤트를 검색할 수 있기 때문입니다. <br>
→ negative <사용자, 이벤트> 쌍의 수가 positive 데이터 포인트보다 훨씬 더 많음

클래스 불균형 문제를 해결하기 위해 다음 기법 중 하나를 사용할 수 있습니다.
* 초점 손실(focal loss) 또는 클래스 균형 손실(class-balanced loss)을 사용하여 분류기(classifier) 훈련
* 다수 클래스 언더 샘플링 <br>

#### ⬛ 손실 함수 선택
이진 분류 모델이므로 **이진 크로스 엔트로피(binary cross-entropy)**와 같은 일반적인 분류 손실 함수를 사용하여 신경망 모델을 최적화 합니다. <br>
→ P(예측) - 이진 크로스 엔트로피 - G(ground truth 레벨)

<br><br>

## 5️⃣<font color = "#0591f5"> 평가</font>
### <font color = "#387af5">오프라인 지표</font>
순위 시스템을 평가하기 위해 다음 옵션을 고려합니다.
* **recall@k 또는 precision@k**
	* 출력의 순위 품질을 고려하지 않기 때문에 적합하지 않음
* **MRR, nDCG 또는 mAP**
	* 순위 품질을 측정하는 일반적으로 사용됨

이벤트는 관련성이 있거나(등록한 경우) 관련성이 없는(보았지만 등록하지 않은) 경우가 많으므로, **mAP가 더 적합**합니다.

##### 📍 MRR
MRR은 목록에서 첫번째 관련 항목의 순위에 초점을 맞추므로, 관련 항목이 한 개로 예상되는 시스템에 적합합니다. 하지만 이벤트 추천 시스템에서는 여러개의 추천 이벤트가 사용자와 관련이 있을 수 있으므로, MRR은 적합하지 않습니다.
##### 📍 nDCG
사용자와 항목 간의 연관성 점수가 이진 형태가 아닌 경우 잘 작동합니다.
##### 📍 mAP
연관성 점수가 이진 형태일 때만 작동합니다.

<br>

### <font color = "#387af5">온라인 지표</font>
이때 비즈니스 목표는 **티켓 판매를 늘려 수익을 늘리는 것**입니다. 시스템이 매출에 미치는 영향을 측정하기 위해 다음 지표를 살펴보겠습니다.
* 클릭률
* 전환율
* 북마크 비율
* 수익 증가율

#### ⬛ 클릭률
추천 이벤트를 본 사용자가 이벤트를 클릭하는 빈도를 보여주는 비율입니다.
* 클릭률 = (클릭 이벤트 총수)/(노출 총수)

클릭률이 높다는건 시스템이 사용자가 클릭하는 이벤트를 잘 추천한다는 것을 의미합니다. 클릭 수가 많으면 일반적으로 더 많은 이벤트에 등록하기 때문입니다. <br>
하지만 이상적으로 추천 이벤트가 사용자에게 얼마나 관련성이 있는지를 측정하는 것이 중요하며, 이는 전환율입니다. <br>

#### ⬛ 전환율
추천 이벤트를 본 사용자가 해당 이벤트에 등록하는 빈도를 나타내는 비율입니다.
* 전환율 = (이벤트 등록 총수)/(노출 총수)

전환율이 높다는 것은 사용자가 추천 이벤트에 더 자주 등록한다는 것을 의미합니다. <br>

#### ⬛ 북마크 비율
사용자가 추천 이벤트를 북마크하는 빈도를 나타내는 비율입니다.

#### ⬛ 수익 증가율
이벤트 추천으로 인한 수익 증가율입니다.

<br><br>

## 6️⃣<font color = "#0591f5"> [서빙] 배포 및 서비스 제공</font>
요청을 처리하는 데 사용할 수 있는 머신러닝 시스템 설계가 필요하며, 두 가지 주요 파이프라인이 있습니다.
* 온라인 학습 파이프라인
* 예측 파이프라인

![image](https://github.com/ysjang0926/ysjang0926.github.io/assets/54492747/dde914a4-d39c-41a1-88ad-8081c4eccae0)


### <font color = "#387af5">온라인 학습 파이프라인</font>
> 데이터 소스>데이터셋 구축>훈련데이터셋>train>훈련된 머신러닝 모델(>모델 저장소)>test>배포

이벤트 추천은 본질적으로 콜드 스타트 방식이며, 지속적으로 새로운 항목이 추가되는 문제가 있습니다. 따라서 **새로운 데이터에 적응하기 위해 모델을 계속 미세 조정**해야 합니다.

온라인 학습 파이프라인은 새로운 데이터를 통합하여 새로운 모델을 지속적으로 학습시키고, 학습된 모델을 평가하고, 배포하는 역할을 담당합니다.

<br>

### <font color = "#387af5">예측 파이프라인</font>
예측 파이프라인은 **특정 사용자와 가장 관련성이 높은 상위 k개의 이벤트를 예측**하는 역할을 담당합니다. <br>
예측 파이프라인의 가장 중요한 몇 가지 구성요소는 다음과 같습니다.

#### ⬛ 이벤트 필터링
> 쿼리 사용자>이벤트 필터링>후보 이벤트
이벤트 필터링 컴포넌트는 쿼리 사용자를 입력으로 받아 **이벤트의 범위를 100만개에서 이벤트의 작은 하위 집합으로 좁힙니다.** 이는 이벤트 위치 또는 기타 유형의 사용자 필터와 같은 간단한 규칙을 기반으로 합니다.
* ex) '콘서트만` 필터를 추가하면 컨포넌트는 후보 이벤트의 하위 집합으로 목록을 좁힘

수백만 개의 이벤트에서 수백 개의 후보 이벤트로 검색 공간을 크게 줄이는 데 사용할 수 있습니다. <br>

#### ⬛ 순위 서비스
필터링 컴포넌트가 생성하 ㄴ사용자 및 후보 이벤트를 입력으로 받아 **각 <사용자, 이벤트> 쌍에 대한 피처를 계산**하고 **모델에서 예측한 확률에 따라 이벤트를 정렬**한 후 **사용자에게 가장 관련성이 높은 상위 k개 이벤트의 순위 목록을 출력**합니다.

순위 서비스는 모델이 기대하는 피처를 계산하는 피처 계산 컴포넌트와 상호작용합니다.
* 정적  피처 : 피처 저장소에서 가져옴
* 동적 피처 : 원시 데이터에서 실시간으로 계산하여 사용

<br><br>

## <font color = "#387af5">🙄 논의 주제</font>
면접에서 언급하기 좋은 주제들입니다.

<details>
<summary> 📣 논의 주제들 </summary>
<div markdown="1">

* 이 시스템에서 관찰할 수 있는 편향의 유형은 무엇인가
* 피처 크로싱을 활용하여 표현력을 높이는 방법
* 일부 사용자는 다양한 이벤트 목록을 보고 싶어하는데, 추천 이벤트를 다양화하고 최소화하려면 어떻게 해야하는지
* 사용자의 속성을 활용하여 모델을 학습한다. 또한 사용자의 실제 위치도 활용한다. 개인 정보 보호 및 보안과 관련된 추가 고려 사항은 무엇인지
* 이벤트 관리 플랫폼은 일반적으로 이벤트 주최자가 공급자가 되고 사용자가 수요자가 되는 양방향 마켓플레이스이다. 시스템이 한쪽에만 최적화되지 않도록 하려면 어떻게 해야하는가?
* 또한, 플랫폼이 여러 호스트에게 공평하게 유지되도록 하려면 어떻게 해야하는가?
* 데이터세트를 구성할 때 데이터 누수를 방지하는 방법
* 모델 업데이트에 적합한 빈도를 결정하는 방법

</div>
</details>

<br><br>

## <font color = "#387af5">✍🏻 Summary</font>
![image](https://github.com/ysjang0926/ysjang0926.github.io/assets/54492747/777a476f-3c05-4f12-b49e-fc601edc47ed)

----------------------------

### 🔜 Think
처음 접하는 내용들이 많아서 생소하여 흐름을 따라가는데 쉽지 않았는데요!😱 <br>
사용자에게 추천 기능을 제공하기 위해서는 어떤 내용들이 구성 되는지를 파악할 수 있어서 좋았습니다. 두번 세번 읽어보면서 흐름을 익혀야겠습니다!
